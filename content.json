{"pages":[],"posts":[{"title":"基于MQTT协议的物联网云端串口波形显示小程序","text":"D-Veda/Serial-over-Internet: 使用MQTT协议基于阿里云平台实现物联网传输的云端串口调试助手 (github.com) 系统原理和实现细节本项目是基于MQTT协议实现机器到机器的物联网通信系统。由于MQTT是一个极其轻量级的发布/订阅消息传输协议，他是专门用于低带宽高延迟或者不可靠的网络环境设计的，因此在本项目中云端串口的通信质量稳定性和硬件性能都有较好的表现。 MQTT它已被用于通过卫星链路与代理通信的传感器、与医疗服务提供者的拨号连接，以及一系列家庭自动化和小型设备场景，因此它也是移动应用的理想选择，因为它体积小，功耗低，数据包最小，并且可以有效地将信息分配给一个或多个接收器。 在整个系统中，由于使用物联网平台进行转发，为了实现通用可靠，所以需要将波形显示相关的数据处理在边缘设备实现完成。在边缘设备上数据采集设备只需要将数据以串行的方式向物联网平台发送数据即可，而串口波形显示终端需要将经由物联网平台转发的数据信息进行提取分析和最后的显示即可实现数据波形功能。 具体实现使用的产品和服务本项目是基于移远QUECTEL BC260Y-CN的NB-IOT模块进行开发的云端串口波形显示系统，该模块作为远程数据采集设备，用于双向通信和单向数据采集。 双向通信：移动应用程序和物联网设备进行双向的数据传输。 单向数据采集：物联网设备向移动应用程序不断发送设备自身获取到的数据。 这里使用阿里云物联网平台作为物联网通信平台，用于对数据采集设备和移动串口波形显示终端的通信数据进行转发。 移动串口波形显示终端使用微信小程序作为波形显示的移动终端。 系统原理基础由于本系统是使用MQTT协议来完成整体数据通信，所以有必要先简单了解MQTT的通信原理和相应的通信机制。实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。 MQTT传输的消息分为：主题（Topic）和负载（Payload）两部分： Topic：可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（Payload）； Payload：可以理解为消息的内容，是指订阅者具体要使用的内容。 MQTT整个服务会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。 这里服务质量有三个等级，不同等级的定义内容如下： QoS 1：”至多一次”，消息发布完全依赖底层TCP/IP网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。这一种方式主要普通APP的推送，若智能设备在消息推送时未联网，推送过去没收到，再次联网也就收不到了。 QoS 2：”至少一次”，确保消息到达，但消息重复可能会发生。 QoS 3：”只有一次”，确保消息到达一次。在一些要求比较严格的计费系统中，可以使用此级别。在计费系统中，消息重复或丢失会导致不正确的结果。这种最高质量的消息发布服务还可以用于即时通讯类的APP的推送，确保用户收到且只会收到一次。 基于MQTT协议的工作原理，物联网平台需要创建MQTT服务实例用于和两个边缘设备（数据采集设备和移动串口波形显示终端）建立会话连接，其作用是充当MQTT代理角色，在创建好的MQTT服务实例上需要为两个边缘设备分别定义Topic，这里两个设备都需要定义一个tx Topic 和一个rx Topic，并同时订阅两台设备自身的tx Topic，这个的作用是将订阅者和发布者之间的数据内容按照数据流向进行分类，tx作为上传主题，rx作为下载主题，这样可以通过平台便于管理设备和设备之间的通信连接，同时也简化通信模式。 物联网平台建立Topic后，两台边缘设备就可以实现与MQTT服务实例进行连接了。两台边缘设备通过配置与物联网平台对接的参数，再订阅每个设备自身对应的rx Topic，即可实现边缘设备和代理之间的通信。设备可以通过向自身的tx Topic发布负载内容实现向代理发送数据信息。代理从订阅的两个rx Topic中接收到边缘设备发送的数据信息，但此时边缘设备之间不能进行相互通信。根据物联网平台服务可以建立设备之间的MQTT消息规则转发，从而实现两台对等设备之间的全双工通信。物联网平台需要在MQTT服务实例上定义规则，将从一台边缘设备发布到代理的tx Topic的数据转发到另一台边缘设备订阅的rx Topic，反过来也是同理。这样就实现了设备与设备之间的相互通信。目前为止，设备之间可以进行简单的双向通信。但移动串口终端仍然不能将数据采集设备发送过来的数据解析并转换成波形图显示。 波形显示实现由于考虑到物联网平台的影响，为了实现波形显示功能的通用性，所以必须减少对物联网平台的依赖性。因此就不能在物联网平台上进行相关的数据解析和数据处理，所以需要在设备之间可以双向通信的基础上，将数据解析和处理的部分在移动串口终端上进行实现。 这里先定义一种通信标准（或者称为协议），数据采集设备上传的数据需要以数据帧的格式向代理发送数据内容，其原因是方便处理。一般的数据帧包括帧头，数据内容和尾部冗余校验。常见的通信协议帧基本都是这样的结构，由于MQTT协议是基于TCP协议封装而成的一个轻量化通信协议，TCP协议是一种可靠的传输协议，即确保数据能够传输到指定目标，因此，可以在常见的数据帧的结构中把尾部冗余校验去掉来降低传输数据的开销，并且保留数据帧头用于区分不同的数据帧。这样就明确了数据帧的收发格式只有帧头和数据内容。 现在可以通过数据帧头识别数据内容的起始位置，来定位读取数据内容信息。需要注意的是，由于受到网络环境，设备硬件等影响，数据采集设备如果每次发送一帧数据则会导致本地获取到的数据和云端显示的数据延迟在不断的增大，所以这里采用一次发送大量的数据帧。移动串口终端需要一次接收大量的数据帧并同时解析提取数据帧中的数据。移动终端在处理数据帧的信息解析和提取的任务之后需要将信息放在缓存区，当缓存区需要更新的时候则将缓存区的数据发送至界面上并显示波形，这里暂时先不谈从缓存区到波形如何显示。当缓存区溢出或者说是数据帧全部都移动到缓存区后会触发缓存区更新，最终实现波形更新显示。 在从缓存区更新数据到波形显示的过程中，移动串口终端每次解析大量的数据帧并把数据帧提取出来的信息按照先入先出的顺序存放至缓存区。当缓存区接收到缓存更新信号时，移动串口终端会从缓存区将数据映射到波形图界面上。 在波形图的显示方式上，由于受到通信环境等其他影响，数据采集设备向移动串口终端发送的消息不一定都是等时长的。那么可以考虑将数据波形显示时根据帧数作为参考来显示具体的波形某一帧的幅值大小，将连续的数据帧用直线段连接即可完成波形图的显示。通过发送设备的发送消息速率和一次消息发送多少帧可以估算出移动串口终端上的波形显示一帧需要多少时间。由此，如果发送的数据信息是具有周期规律的，那么可以计算出波形的周期、频率等一些必要参数。 确定了波形显示参考方式后，那么就只有具体的波形绘制方法需要解决。常见的波形显示只需要将界面等间隔的几列上将不同帧上的数据经过一定比例转换后，在一列上显示一定的高度或者距离用来表示当前帧或者时刻上的幅值信息。但由于不同情况下波形分析的不同需求，所以需要做到不同单位帧数的波形显示，此效果和示波器调整横向的时间轴效果一致。基于上述需求分析，将波形可以显示的界面宽度等间距分成不同数量后，每间隔一段相等距离更新一帧数据，最后形成一个完整波形。当需要跳帧横向单位帧数时，通过改变界面宽度的等分数量来调整列和列之间的间距最后在每一列上将数据进行转换然后绘制实现波形的拉伸。 按照上述分析就实现了云端串口波形显示系统。 附图 系统工作框图 MQTT物联网平台连接关系 数据缓存更新流程","link":"/2022/680098d399fd/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/a4beea82e0a2/"},{"title":"Hexo+Nginx+Trojan-Go搭建总结（Debian环境）","text":"由于平时在找资料时会经常用到一些科学上网工具，但在使用过程中发现大厂服务较贵，而其他一些个人或者小团体维护的服务虽然价格相对低廉，但没有大厂稳定。当然，还是因为价格为主等其他的原因导致体验没有达到预期的效果，所以这里自己搭建一个廉价梯子。由于之前搭建梯子时使用过SS、VMESS、VLESS等其他协议，且经常发生端口被禁的现象导致网上冲浪体验就没了，所以不沿用之前的方案，又因为这个博客有一个域名，加上想把博客移到个人服务器上等原因，所以这次选择Trojan-Go协议来搭建。 科学上网不同协议的比较选择参考 科学上网工具哪个好？一灯不是和尚为您科普VPN/SS/SSR/V2Ray/Xray/Trojan/Trojan-Go和WireGuard的前世今生、区别和关系以及梯子软件的前景 - 一灯不是和尚 (iyideng.vip) 科学上网的主流协议大对比！这里面有你在使用的吗？ | TechFen’s Blog (techfens.com) 考虑到只有一个域名且已经被用于博客了，而一个域名通常来说只解析到一个网站上。所以使用二级域名给Trojan-Go进行HTTPS的伪装，又由于想实现Hexo在个人服务器上的部署则需要使用，于是将博客同时部署到GitHub和VPS上实现网站备份的效果和科学上网。 在开始之前需要在原来的域名解析条目中添加一个指向VPS的IP条目，记录值是VPS的IP地址，效果类似如下。 这里使用的是阿里云的域名，其中主机记录为@表示直接解析域名（d-veda.top），如果存在多条记录值相同的记录会产生冲突（如果解析路线不同则可以消除冲突，最好一个域名对应一个地址）。 注意：由于VPS只有IP能访问所以这里添加的是A记录，而原来域名解析指向的是域名（d-veda.github.io），所以用的是CNAME记录。这里用的境外解析路线只是避免冲突（文本所使用的方法），推荐使用二级域名指向VPS的IP地址（例如，主机记录为abc，已有域名为xxx.com，则abc.xxx.com为xxx.com的二级域名，添加一个这样的A记录指向VPS的IP地址即可）。 添加完成后再将Hexo部署到VPS上。若不需要Hexo部署至VPS可以跳过下一节。 Hexo部署推送Hexo是通过git推送静态网页文件到仓库的，因此，需要在VPS搭建一个git仓库（使用root用户）。 12345apt install git # 安装git。adduser git # 添加用户git，专用于git仓库管理。这里会提示添加用户信息和对应的密码。su git # 使用git用户进行操作。cd ~git init --bare blog.git # 创建名称为blog的空仓库。 这里使用git作为新添加的用户名是为了和常用的git代码托管平台统一，用户名可以是其他内容。使用--bare创建空仓库方便将仓库内容和git数据分离。 在创建好git仓库后，可以尝试在本地终端git clone一下VPS的仓库（这里会提示输入相关用户的密码）。 1git clone git@IP:/home/git/blog.git 这里的IP就是VPS的IP地址，如果VPS中的git仓库所有者不是git则需要将git修改为对应的用户名称。终端若出现如下所示的内容，则表示VPS上的仓库建立成功了。 1warning: You appear to have cloned an empty repository. 现在需要向本地的Hexo博客配置文件_config.yml中的部署参数添加VPS的git仓库信息，内容如下。 123456deploy: type: git repo: github: https://github.com/D-Veda/D-Veda.github.io.git VPS: git@IP:/home/git/blog.git # 新添加的git仓库地址。 branch: master 注意缩进会影响Hexo生成静态网页。IP替换VPS对应的IP地址，这里有两个部署的地址，前面的名称（github和VPS）是自己添加的，且可以自己定义。 配置好Hexo的部署地址后需要将VPS上新建的git仓库配置git hook（git钩子）。这么做是为了实现git仓库的自动部署。若不做git钩子进行自动部署，则在VPS中会找不到推送过来的文件（当然也可以不用git钩子，用自定义的脚本也可以实现对应的自动部署功能）。 配置git hook操作如下（使用git用户，不要用root）。 1vim ~/blog.git/hooks/post-update.sample # 修改post-update.sample文件中的命令。 在post-update.sample文件中将原有的内容修改成如下所示的内容保存。 12345678#!/bin/sh## An example hook script to prepare a packed repository for use over# dumb transports.## To enable this hook, rename this file to &quot;post-update&quot;.exec git --work-tree=/var/www/blog --git-dir=/home/git/blog.git checkout -f 注意：这里的--work-tree对应git仓库的工作区目录（这里使用/var/www/blog作为工作区目录是为了对应之后的Nginx所提供的目录，也可以使用其他目录且需要自行创建），--git-dir对应git仓库目录，checkout和-f用于强制覆盖原有文件。 工作区目录需要根据自己的定义的位置进行创建（这里使用root用户进行工作区目录的创建）。 1234cd /varmkdir www &amp;&amp; cd ./www # 若有www目录则不用创建，cd进入即可。mkdir blogchown -R git:git ./blog # 将blog目录的所有者变为git用户。 编辑好post-update.sample和创建好工作区目录后再进行如下操作。 123su git # 使用git用户进行操作。mv ~/blog.git/hooks/post-update.sample ~/blog.git/hooks/post-update # 重命名，去掉sample后缀。chmod +x ~/blog.git/hooks/post-update # 给post-update文件添加可执行权限。 上述操作原理参考Git - Git 钩子 (git-scm.com)。 配置完成后可以尝试使用hexo d进行部署，按照提示输入git用户密码后，将静态网页文件推送到VPS的git仓库中。推送成功后在之前的工作区目录（/var/www/blog）可以找到推送的文件，Hexo双部署到此就实现完成了。如果VPS工作区没有收到对应的推送文件则是前几步有误，需要自己排查。 注意：由于Hexo是增量推送更新，所以每次hexo g -d如果文件内容都没有改动，Hexo不会触发git钩子进行自动部署。若要触发git钩子进行自动部署，则需要在Hexo部署前将任意内容文件稍微改动一下（随便一篇文章稍微改一下内容）并先hexo clean再hexo g -d进行生成部署。如果上述操作不能触发git钩子，则需要检查VPS中仓库的post-update文件、hooks目录和工作区目录对于git用户来说是否具有相应权限，还有相应文件的配置是否有误。 Nginx搭建部署在Hexo成功部署到VPS后需要使用HTTP服务将静态网页文件显示出来，这里使用Nginx的HTTP服务，操作（使用root用户）如下。 1apt install nginx # 安装Nginx。 安装完成后修改Nginx配置文件信息。 1vim /etc/nginx/nginx.conf # 修改nginx.conf文件配置信息。 将nginx.conf文件第一行的用户名改成root后保存，如下图所示。 1vim /etc/nginx/sites-available/default # 修改default文件信息。 将default文件中root改为自己git工作区目录，server_name改为自己的域名（此域名需要解析指向VPS的IP地址），如下图所示。 将default文件最下面的server段内容去掉注释后把侦听端口号、服务器域名、根目录都修改成相应信息，这里使用的是8080端口避免Nginx默认情况下的80端口被占用，如下图所示。 配置好文件后保存。使用nginx -t检测Nginx配置是否有误，以便故障排查。 在Nginx完成HTTP服务配置之前需要确认VPS防火墙中相应的端口是否开启。 1ufw status # 使用ufw查看防火前端口规则列表。 例如这里使用的是22、80、443、8080端口。22端口用于本地终端与VPS的SSH协议连接，80，8080用于Nginx的HTTP服务端口，443端口用于之后Trojan-Go协议的HTTPS伪装。 如果防火墙端口规则列表中没有相应的端口规则，则需要手动开启相应的规则，操作如下所示。 1ufw allow PORT 这里的PORT替换需要放开的端口号。检查无误后重启Nginx服务，命令如下。 1nginx -s reload 如果Nginx提示端口被占用的错误，则可以使用netstat -nlp查看相应的端口占用情况，使用ps -ef | grep name（name需要被占用对应端口的应用名称替换）将对应占用端口的进程清除即可开启Nginx服务。现在可以直接使用IP访问网站，如果加载失败则需要在之前几步进行故障排查。 申请获取SSL证书参考Trojan-Go官方文档，从Let’s Encrypt证书颁发机构中获取证书。根据Let’s Encrypt的建议，推荐使用Certbot ACME 客户端。它可以在不下线您的服务器的前提下自动执行证书颁发和安装。 根据Certbot 说明 |Certbot (eff.org)描述，需要先将系统自带的certbot版本进行删除，然后安装snap商店中的certbot进行使用，具体操作如下（使用root用户）。 123456789apt update # 更新源列表。apt install snapd # 安装snapd。snap install core # 获取最新的core snapd。snap refresh core # 检查snap是否为最新版本。apt remove certbot # 删除系统自带的certbot。apt autoremove # 删除多余的依赖程序。snap install --classic certbot # 使用snap安装certbot。ln -s /snap/bin/certbot /usr/bin/certbot # 为certbot创建软连接，便于执行。certbot certonly --nginx # 只获取证书不修改Nginx服务配置 这里采用只获取证书不修改Nginx服务配置是因为若certbot修改了Nginx服务配置则会让Nginx服务开启HTTPS协议，Nginx会占用443端口，而Trojan-Go需要伪装HTTPS也要占用443。这样会造成端口冲突，所以certbot不能直接修改Nginx服务配置。在certbot获取证书失败时，需要检查域名解析是否正常工作。至此SSL证书可以成功获取。 Trojan-Go对端搭建Trojan-Go使用Go实现的完整Trojan代理，兼容原版Trojan协议及配置文件格式。安全、高效、轻巧、易用。参考p4gefau1t/trojan-go和Trojan-Go Docs文档进行相应配置（使用root用户）。 1234cd ~wget https://github.com/p4gefau1t/trojan-go/releases/download/v0.10.6/trojan-go-linux-amd64.zip # 下载Trojan-Go可执行文件。apt install unzip # 安装unzip解压工具。unzip -d ./trojan-go trojan-go-linux-amd64.zip # 解压官方压缩包。 解压完成后，官方在./example目录中提供了相关的配置参考文件和服务启动参考文件，根据提供的参考文件稍作修改即可使用，操作如下。 12345ln -s /root/trojan-go/trojan-go /usr/bin/trojan-go # 创建软连接，方便运行cd ~/trojan-gomkdir configcp ./example/server.json ./configcp ./example/trojan-go.service /usr/lib/systemd/system/ 将相关的配置文件放到对应的位置后，对Trojan-Go配置进行修改，操作如下。 1vim /root/trojan-go/config/server.json # 修改Trojan-Go配置文件信息 参考配置如下： 123456789101112131415{ &quot;run_type&quot;: &quot;server&quot;, &quot;local_addr&quot;: &quot;0.0.0.0&quot;, &quot;local_port&quot;: 443, &quot;remote_addr&quot;: &quot;127.0.0.1&quot;, &quot;remote_port&quot;: 8080, &quot;password&quot;: [ &quot;Your password&quot; ], &quot;ssl&quot;: { &quot;cert&quot;: &quot;/path/to/your/fullchain&quot;, &quot;key&quot;: &quot;/path/to/your/privkey&quot;, &quot;fallback_port&quot;: 8080 }} 注意：这里的remote_port需要和Nginx配置的8080端口相对应，cert和key填写由certbot获取到的两个密钥文件地址，fallback_port作为当Trojan-Go检测到通信异常时会将数据转发到对应的端口，这里需要和Nginx所配置的8080端口对应。 配置完成后尝试开启trojan-go服务端，查看是否运行正常，操作如下。 1trojan-go -config /root/trojan-go/config/server.json 若出现如下提示且没有[ERROR]提示，则表示trojan-go服务端工作正常。 然后配置trojan-go的开机启动服务，操作如下。 1vim /usr/lib/systemd/system/trojan-go.service 将启动服务文件中的User中的nobody改为root，检查配置文件所在地址无误保存即可。 1234567891011121314151617[Unit]Description=Trojan-Go - An unidentifiable mechanism that helps you bypass GFWDocumentation=https://p4gefau1t.github.io/trojan-go/After=network.target nss-lookup.target[Service]User=rootCapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICEAmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICENoNewPrivileges=trueExecStart=/usr/bin/trojan-go -config /root/trojan-go/config/server.jsonRestart=on-failureRestartSec=10sLimitNOFILE=infinity[Install]WantedBy=multi-user.target 注册开机启动服务，并检测trojan-go服务运行状态。 123systemctl enable trojan-go # 开机启动service trojan-go start # 立即启动服务systemctl status trojan-go # 检测服务运行状态 trojan-go服务端的基本配置就都结束了。 这里使用Qv2ray作为trojan-go客户端，在安装Qv2ray后需要将其添加QvPlugin-Trojan-Go插件才能进行连接。参考使用插件 | Qv2ray文档安装trojan-go插件后，新建连接，需要填写的内容只有主机（填服务器的IP地址或域名）和Password（填设trojan-go服务端设置的密码），点击OK保存。 完成设置后右击新建好的连接，点击连接到此服务器，成功即搭建完成。 若仍有其他问题则检查服务端和客户端的相关配置是否一致等其他问题，完成整体搭建。 Qv2ray其他配置参考 Qv2ray高级路由设置策略 解决UWP应用在Qv2ray连接时不能上网的问题 高级路由设置规则 v2ray局域网共享方案（Qv2ray类似） Hexo+Nginx+Trojan-Go的整体部署方案仅供参考，本文仅对搭建过程进行相关记录。","link":"/2022/49cb7788a599/"}],"tags":[{"name":"MQTT","slug":"mqtt","link":"/tags/mqtt/"},{"name":"IOT","slug":"iot","link":"/tags/iot/"},{"name":"Hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"Trojan-Go","slug":"trojan-go","link":"/tags/trojan-go/"},{"name":"VPS","slug":"vps","link":"/tags/vps/"},{"name":"Qv2ray","slug":"qv2ray","link":"/tags/qv2ray/"}],"categories":[{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"DIY","slug":"diy","link":"/categories/diy/"}]}